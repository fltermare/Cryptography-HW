/*Hand in this file ONLY!*/
/*Hand in this file ONLY!*/
/*Hand in this file ONLY!*/
int L1_0 = 0; int L1_8 = 8; int L1_13 = 13; 
int L1_16 = 16; int L1_17 = 17; int L1_18 = 18;
int L2_0 = 0; int L2_10 = 10; int L2_20 = 20; int L2_21 = 21;
int L3_0 = 0; int L3_7 = 7; int L3_10 = 10; 
int L3_20 = 20; int L3_21 = 21; int L3_22 = 22;

struct point {
	int* pl1;
	int* pl2;
	int* pl3;
};

void* A51Initial(unsigned long long sessionKey,unsigned int frameCounter){
/* Using this funciton to initialize your A5-1 stream cipher state.
 * sessionKey: a 64-bit unsigned integer
 *             This should be used from LSB to MSB
 *   Ex. sessionKey = 0x000000000000000b = 0b0000...00001011
 *       Then, it will be translate to "1101 0000 ... 0000" in the video
 * frameCounter: a 22-bit unsigned integer
 *               This should be used from LSB to MSB, the same as sessionKey
 * This funtion returns a structure defined by yourself to keep the 
 * stream cipher state
 */

	
/*Your code...*/

	static int L1[19] = {0};	//LFSR
	static int L2[22] = {0};
	static int L3[23] = {0};
	
	int s[64];			//sessionKey
	for (int i = 0; i < 64; i=i+4) {
		int temp;
		temp = (sessionKey >> i) % 16;
		for (int j = 0; j < 4; j++) {
			s[i+j] = (temp >> j) % 2;
		}
	}

	int f[22];			//frameCounter
	for (int i = 0; i < 22; i = i + 4) {
		int temp;
		temp = (frameCounter >> i) % 16;
		for (int j = 0; j < 4 && j+i < 22; j++) {
			f[i+j] = (temp >> j) % 2;
		}
	}
	//STEP2
	for (int i = 0; i < 64; i++ ) {
		L1[L1_18] = s[i] ^ L1[L1_18--] ^ L1[L1_17--] ^ 
					L1[L1_16--] ^ L1[L1_13--]; 
		L1_0--;
		L1_8--;
		while (L1_0 < 0) L1_0 += 19;
		while (L1_8 < 0) L1_8 += 19;
		while (L1_13 < 0) L1_13 += 19;
		while (L1_16 < 0) L1_16 += 19;
		while (L1_17 < 0) L1_17 += 19;
		while (L1_18 < 0) L1_18 += 19;
		
		L2[L2_21] = s[i] ^ L2[L2_21--] ^ L2[L2_20--];
		L2_0--;
		L2_10--;
		while (L2_0 < 0) L2_0 += 22;
		while (L2_10 < 0) L2_10 += 22;
		while (L2_20 < 0) L2_20 += 22;
		while (L2_21 < 0) L2_21 += 22;

		L3[L3_22] = s[i] ^ L3[L3_22--] ^ L3[L3_21--] ^ 
					L3[L3_20--] ^ L3[L3_7--];
		L3_0--;
		L3_10--;
		while (L3_0 < 0) L3_0 += 23;
		while (L3_7 < 0) L3_7 += 23;
		while (L3_10 < 0) L3_10 += 23;
		while (L3_20 < 0) L3_20 += 23;
		while (L3_21 < 0) L3_21 += 23;
		while (L3_22 < 0) L3_22 += 23;
		
	}
	//step3
	for (int i = 0; i < 22; i++ ) {
		L1[L1_18] = f[i] ^ L1[L1_18--] ^ L1[L1_17--] ^ 
					L1[L1_16--] ^ L1[L1_13--]; 
		L1_0--;
		L1_8--;
		while (L1_0 < 0) L1_0 += 19;
		while (L1_8 < 0) L1_8 += 19;
		while (L1_13 < 0) L1_13 += 19;
		while (L1_16 < 0) L1_16 += 19;
		while (L1_17 < 0) L1_17 += 19;
		while (L1_18 < 0) L1_18 += 19;
		
		L2[L2_21] = f[i] ^ L2[L2_21--] ^ L2[L2_20--];
		L2_0--;
		L2_10--;
		while (L2_0 < 0) L2_0 += 22;
		while (L2_10 < 0) L2_10 += 22;
		while (L2_20 < 0) L2_20 += 22;
		while (L2_21 < 0) L2_21 += 22;

		L3[L3_22] = f[i] ^ L3[L3_22--] ^ L3[L3_21--] ^ 
					L3[L3_20--] ^ L3[L3_7--];
		L3_0--;
		L3_10--;
		while (L3_0 < 0) L3_0 += 23;
		while (L3_7 < 0) L3_7 += 23;
		while (L3_10 < 0) L3_10 += 23;
		while (L3_20 < 0) L3_20 += 23;
		while (L3_21 < 0) L3_21 += 23;
		while (L3_22 < 0) L3_22 += 23;
	}
	//step4
	int majority;
	int flag;
	for (int i = 0; i < 100; i++ ) {
		majority = L1[L1_8] + L2[L2_10] + L3[L3_10];
		if (majority >= 2) flag = 1;
		else flag = 0;

		if (L1[L1_8] == flag) {
			L1[L1_18] = L1[L1_18--] ^ L1[L1_17--] ^ L1[L1_16--] ^ L1[L1_13--];
			L1_0--;
			L1_8--;
			while (L1_0 < 0) L1_0 += 19;
			while (L1_8 < 0) L1_8 += 19;
			while (L1_13 < 0) L1_13 += 19;
			while (L1_16 < 0) L1_16 += 19;
			while (L1_17 < 0) L1_17 += 19;
			while (L1_18 < 0) L1_18 += 19;
		}
		if (L2[L2_10] == flag) {
			L2[L2_21] = L2[L2_21--] ^ L2[L2_20--];
			L2_0--;
			L2_10--;
			while (L2_0 < 0) L2_0 += 22;
			while (L2_10 < 0) L2_10 += 22;
			while (L2_20 < 0) L2_20 += 22;
			while (L2_21 < 0) L2_21 += 22;
		}
		if (L3[L3_10] == flag) {
			L3[L3_22] = L3[L3_22--] ^ L3[L3_21--] ^ L3[L3_20--] ^ L3[L3_7--];
			L3_0--;
			L3_10--;
			while (L3_0 < 0) L3_0 += 23;
			while (L3_7 < 0) L3_7 += 23;
			while (L3_10 < 0) L3_10 += 23;
			while (L3_20 < 0) L3_20 += 23;
			while (L3_21 < 0) L3_21 += 23;
			while (L3_22 < 0) L3_22 += 23;
		}
	}
	static struct point L;
	L.pl1 = L1;
	L.pl2 = L2;
	L.pl3 = L3;
	void* LFSR;
	LFSR = &L;
	return LFSR;
}
 
unsigned char A51GetByte(void* LFSR){
/* Using this function to get a 8-bit key stream from the current state
 * LFSR: the current A5-1 stream cipher state
 * This function returns an unsigned char which generated by your A5-1
 *      The 8-bit key stream is generated from MSB to LSB
 *   Ex. The generated 8-bit key stream = 0 1 0 0 1 1 0 1
 *       Then, the returned unsigned char is 0x4d = 77
 */

/*Your code...*/
	int majority, flag;
	static int first = 0;
	int L[8];
	for (int i = 0; i < 8; i++ ) {
		L[i] = *(((point*)LFSR)->pl1 + L1_18) ^ *(((point*)LFSR)->pl2 + L2_21) ^ *(((point*)LFSR)->pl3 + L3_22);
				//L[i] = l1[L1_18] ^ l2[L2_21] ^ l3[L3_22];	
		majority = *(((point*)LFSR)->pl1 + L1_8) + *(((point*)LFSR)->pl2 + L2_10) + *(((point*)LFSR)->pl3 + L3_10); 
				//	l1[L1_8] + l2[L2_10] + l3[L3_10];
		if (majority >= 2) flag = 1;
		else flag = 0;

		if (*(((point*)LFSR)->pl1 + L1_8) == flag) {
			*(((point*)LFSR)->pl1 + L1_18) = *(((point*)LFSR)->pl1 + L1_18) ^ 
											*(((point*)LFSR)->pl1 + L1_17) ^
											*(((point*)LFSR)->pl1 + L1_16) ^
											*(((point*)LFSR)->pl1 + L1_13); 
			L1_0 = (L1_0 - 1) % 19;
			L1_8 = (L1_8 - 1) % 19;
			L1_13 = (L1_13 - 1) % 19;
			L1_16 = (L1_16 - 1) % 19;
			L1_17 = (L1_17 - 1) % 19;
			L1_18 = (L1_18 - 1) % 19;
			while (L1_0 < 0) L1_0 += 19;
			while (L1_8 < 0) L1_8 += 19;
			while (L1_13 < 0) L1_13 += 19;
			while (L1_16 < 0) L1_16 += 19;
			while (L1_17 < 0) L1_17 += 19;
			while (L1_18 < 0) L1_18 += 19;

			//l1[L1_0] = l1[L1_18] ^ l1[L1_17] ^ l1[L1_16] ^ l1[L1_13];
		  
		}
		if (*(((point*)LFSR)->pl2 + L2_10) == flag) {
			*(((point*)LFSR)->pl2 + L2_21) = *(((point*)LFSR)->pl2 + L2_21) ^ 
											*(((point*)LFSR)->pl2 + L2_20);
			L2_0 = (L2_0 - 1) % 22;
			L2_10 = (L2_10 - 1) % 22;
			L2_20 = (L2_20 - 1) % 22;
			L2_21 = (L2_21 - 1) % 22;
			while (L2_0 < 0) L2_0 += 22;
			while (L2_10 < 0) L2_10 += 22;
			while (L2_20 < 0) L2_20 += 22;
			while (L2_21 < 0) L2_21 += 22;

			
			//l2[L2_0] = l2[L2_21] ^ l2[L2_20];
		  
		}
		if (*(((point*)LFSR)->pl3 + L3_10) == flag) {
			*(((point*)LFSR)->pl3 + L3_22) = *(((point*)LFSR)->pl3 + L3_22) ^ 
											*(((point*)LFSR)->pl3 + L3_21) ^
											*(((point*)LFSR)->pl3 + L3_20) ^
											*(((point*)LFSR)->pl3 + L3_7);
			L3_0 = (L3_0 - 1) % 23;
			L3_7 = (L3_7 - 1) % 23;
			L3_10 = (L3_10 - 1) % 23;
			L3_20 = (L3_20 - 1) % 23;
			L3_21 = (L3_21 - 1) % 23;
			L3_22 = (L3_22 - 1) % 23;
			while (L3_0 < 0) L3_0 += 23;
			while (L3_7 < 0) L3_7 += 23;
			while (L3_10 < 0) L3_10 += 23;
			while (L3_20 < 0) L3_20 += 23;
			while (L3_21 < 0) L3_21 += 23;
			while (L3_22 < 0) L3_22 += 23;

	
			//l3[L3_0] = l3[L3_22] ^ l3[L3_21] ^ l3[L3_20] ^ l3[L3_7];
		  
		}
	}
	unsigned char c;	
	for (int i = 0; i < 8; i++) {
		c = c << 1;
		c = c ^ L[i];
	}
	return c;
}
